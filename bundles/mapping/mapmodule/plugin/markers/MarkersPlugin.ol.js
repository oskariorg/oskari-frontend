import olSourceVector from 'ol/source/Vector';
import olLayerVector from 'ol/layer/Vector';
import olFeature from 'ol/Feature';
import * as olGeom from 'ol/geom';

import '../../request/AddMarkerRequest';
import '../../request/AddMarkerRequestHandler';
import '../../request/RemoveMarkersRequest';
import '../../request/RemoveMarkersRequestHandler';
import '../../request/MarkerVisibilityRequest';
import '../../request/MarkerVisibilityRequestHandler';

import '../../event/AfterAddMarkerEvent';
import '../../event/MarkerClickEvent';
import '../../event/AfterRemoveMarkersEvent';
import { showAddMarkerPopup } from './MarkersForm';
import { ID_PREFIX, PLUGIN_NAME, TOOL_GROUP, DEFAULT_STYLE, STYLE_TYPE, DEFAULT_DATA, SEPARATORS } from './constants';

/**
 * @class Oskari.mapframework.mapmodule.MarkersPlugin
 * Provides marker functionality for the map.
 */
Oskari.clazz.define('Oskari.mapframework.mapmodule.MarkersPlugin',

    /**
     * @method create called automatically on construction
     * @static
     */
    function () {
        this._clazz =
            'Oskari.mapframework.mapmodule.MarkersPlugin';
        this._name = PLUGIN_NAME;

        this._hiddenMarkers = {}; // id: olFeature
        this._styleData = {}; // store values as it's hard to get them from feature's ol style

        this.buttons = null;
        this.dialog = null;
        this._buttonsAdded = false;
        this._showAddMarkerPopupOnMapClick = false;

        // Show the marker button
        this._layer = undefined;
        this.log = Oskari.log(PLUGIN_NAME);
        this.popupControls = null;
        this.popupCleanup = () => {
            if (this.popupControls) {
                this.popupControls.close();
                this._showAddMarkerPopupOnMapClick = true;
            }
            this.popupControls = null;
        };
    }, {

        /**
         * @method hasUI
         * @return {Boolean} true
         * This plugin has an UI so always returns true
         */
        hasUI: function () {
            return true;
        },

        _createEventHandlers: function () {
            return {
                MapClickedEvent: event => this._mapClick(event),
                'Toolbar.ToolbarLoadedEvent': () => this._registerTools(),
                'Toolbar.ToolSelectedEvent': event => {
                    if (event.getToolId() !== 'addMarker' && event.getSticky()) {
                        this.stopMarkerAdd(false);
                    }
                }
            };
        },

        _createRequestHandlers: function () {
            var me = this;
            var sandbox = me.getSandbox();
            return {
                'MapModulePlugin.AddMarkerRequest': Oskari.clazz.create(
                    'Oskari.mapframework.bundle.mapmodule.request.AddMarkerRequestHandler',
                    sandbox,
                    me
                ),
                'MapModulePlugin.RemoveMarkersRequest': Oskari.clazz.create(
                    'Oskari.mapframework.bundle.mapmodule.request.RemoveMarkersRequestHandler',
                    sandbox,
                    me
                ),
                'MapModulePlugin.MarkerVisibilityRequest': Oskari.clazz.create(
                    'Oskari.mapframework.bundle.mapmodule.request.MarkerVisibilityRequestHandler',
                    sandbox,
                    me
                )
            };
        },

        /**
         * @method register
         * Interface method for the plugin protocol
         */
        register: function () {
            this.getMapModule().setLayerPlugin('markers', this);
        },
        /**
         * @method unregister
         * Interface method for the plugin protocol
         */
        unregister: function () {
            this.getMapModule().setLayerPlugin('markers', null);
        },

        /**
         * @private @method _startPluginImpl
         * Interface method for the plugin protocol.
         * Creates the base marker layer.
         */
        _startPluginImpl: function () {
            this.dialog = Oskari.clazz.create(
                'Oskari.userinterface.component.Popup'
            );
            this.buttons = {
                addMarker: {
                    iconCls: 'marker-share',
                    tooltip: this.getMsg('tooltip'),
                    sticky: true,
                    callback: () => this.startMarkerAdd()
                }
            };
            // Register marker tools
            this._registerTools();
        },
        /**
         * Requests the tools to be added to the toolbar.
         *
         * @method registerTool
         */
        _registerTools: function () {
            const { markerButton } = this.getConfig();
            if (this._buttonsAdded || markerButton === false) {
                return;
            }
            const sandbox = this.getSandbox();
            if (!sandbox.hasHandler('Toolbar.AddToolButtonRequest')) {
                // Couldn't get the request, toolbar not loaded
                return;
            }
            const reqBuilder = Oskari.requestBuilder('Toolbar.AddToolButtonRequest');
            Object.keys(this.buttons).forEach(btnName => {
                const request = reqBuilder(btnName, TOOL_GROUP, this.buttons[btnName]);
                sandbox.request(this.getName(), request);
            });
            this._buttonsAdded = true;
        },
        /**
         * Handles generic map click
         * @private
         * @param  {Oskari.mapframework.bundle.mapmodule.event.MapClickedEvent} event map click
         */
        _mapClick: function (event) {
            const { lon, lat } = event.getLonLat();
            const coord = [lon, lat];
            if (!this._showAddMarkerPopupOnMapClick) {
                this.getMarkersLayer().getSource().getFeaturesAtCoordinate(coord).forEach(feat => this._markerClicked(feat.getId()));
                return;
            }
            // adding a marker
            this._showAddMarkerPopupOnMapClick = false;
            const onAdd = style => {
                this.popupCleanup();
                this._addMarkerFromPopup(coord, style);
            };
            this.popupControls = showAddMarkerPopup(onAdd, this.popupCleanup);
        },
        /**
         * Called when a marker has been clicked.
         * @method  _markerClicked
         * @private
         * @param  {String} markerId which was clicked
         */
        _markerClicked: function (markerId) {
            const clickEvent = Oskari.eventBuilder('MarkerClickEvent')(markerId);
            this.getSandbox().notifyAll(clickEvent);
        },
        getMarkersLayer: function () {
            if (!this._layer) {
                this._layer = new olLayerVector({ title: 'Markers', source: new olSourceVector() });
                this.getMapModule().addOverlayLayer(this._layer);
            }
            return this._layer;
        },
        getOLMapLayers: function () {
            return [];
        },
        getMapMarkerBounds: function () {
            return this.getMarkersLayer().getSource().getExtent();
        },
        /**
         * Activate the "add marker mode" on map.
         */
        startMarkerAdd: function () {
            this.enableGfi(false);
            this._showAddMarkerPopupOnMapClick = true;
            const clearBtn = Oskari.clazz.create('Oskari.userinterface.component.Button');
            const closeBtn = Oskari.clazz.create('Oskari.userinterface.component.buttons.CloseButton');

            clearBtn.setTitle(this.getMsg('dialog.clear'));
            clearBtn.setHandler(() => this.removeMarkers());
            closeBtn.setHandler(() => this.stopMarkerAdd(true));
            closeBtn.setPrimary(true);

            this.dialog.show(
                this.getMsg('title'),
                this.getMsg('dialog.message'),
                [clearBtn, closeBtn]
            );
            this.getMapModule().setCursorStyle('crosshair');
            this.dialog.moveTo(
                '#toolbar div.toolrow[tbgroup=default-selectiontools]',
                'bottom'
            );
        },
        /**
         * Stops the marker location selector
         */
        stopMarkerAdd: function (selectDefault) {
            this.enableGfi(true);
            this._showAddMarkerPopupOnMapClick = false;
            if (this.dialog) {
                this.dialog.close(true);
            }
            this.popupCleanup();
            this.getMapModule().setCursorStyle('');
            if (!selectDefault) {
                return;
            }
            // ask toolbar to select default tool if available
            const toolbarRequest = Oskari.requestBuilder('Toolbar.SelectToolButtonRequest');
            if (toolbarRequest) {
                this.getSandbox().request(this, toolbarRequest());
            }
        },
        addMapMarker: function (markerData, markerId) {
            // Combine default values with given values
            const { id, x, y, ...styleData } = this._getSanitizedMarker(markerData, markerId);
            if (!id) {
                // validation failed
                this.log.warn('Error while adding marker');
                return;
            }
            this._styleData[id] = styleData;
            const style = this._getStyleFromMarkerData(styleData);
            this._addMarkerToMap(id, [x, y], style);
        },
        removeMarkers: function (id) {
            if (id) {
                delete this._hiddenMarkers[id];
                delete this._styleData[id];
                this._removeMarkerFromMap(id);
            } else {
                // remove all
                this.getMarkersLayer().getSource().clear();
                this._hiddenMarkers = {};
                this._styleData = {};
            }
            const removeEvent = Oskari.eventBuilder('AfterRemoveMarkersEvent')(id);
            this.getSandbox().notifyAll(removeEvent);
        },
        _getSanitizedMarker: function (markerData, markerId) {
            const { x, y, shape, msg, color, ...other } = markerData;
            // Validation: coordinates are needed
            if ((typeof x === 'undefined') || (typeof y === 'undefined')) {
                this.log.warn('Undefined coordinate in', markerData);
                return {};
            }
            // generate id if not provided
            const id = markerId || ID_PREFIX + Oskari.getSeq(this.getName()).nextVal();
            const sanitized = { id, x, y, ...DEFAULT_DATA };

            if (typeof shape !== 'undefined') {
                sanitized.shape = isNaN(shape) ? shape : parseInt(shape);
            }
            if (msg) {
                sanitized.msg = decodeURIComponent(msg);
            }
            if (color) {
                sanitized.color = color.charAt(0) === '#' ? color.substring(1) : color;
            }
            Object.keys(other).forEach(key => {
                const value = other[key];
                if (typeof value !== 'undefined') {
                    sanitized[key] = value;
                }
            });
            return sanitized;
        },
        _getStyleFromMarkerData: function (markerData) {
            const style = jQuery.extend(true, {}, DEFAULT_STYLE);
            const { color, shape, size, msg, offsetX, offsetY } = markerData;
            style.image.fill.color = '#' + color;
            style.image.shape = shape;
            style.text.labelText = msg;
            // use pixel size if shape is svg or url
            if (typeof shape === 'string') {
                style.image.sizePx = size;
            } else {
                style.image.size = size;
            }
            if (typeof offsetX !== 'undefined') {
                style.image.offsetX = offsetX;
            }
            if (typeof offsetY !== 'undefined') {
                style.image.offsetY = offsetY;
            }
            return style;
        },
        _addMarkerFromPopup: function (coord, style) {
            const id = ID_PREFIX + Oskari.getSeq(this.getName()).nextVal();
            const { image, text } = style;
            const { fill, shape, size } = image;
            const styleData = {
                color: fill.color.substring(1),
                shape,
                size,
                msg: text.labelText
            };
            this._styleData[id] = styleData;
            this._addMarkerToMap(id, coord, style);
        },

        _addMarkerToMap: function (id, coord, style) {
            const layerSource = this.getMarkersLayer().getSource();
            const olStyle = this.getMapModule().getStyle(style, STYLE_TYPE);

            const feature = new olFeature(new olGeom.Point(coord));
            feature.setId(id);
            feature.setStyle(olStyle);

            if (layerSource.hasFeature(feature)) {
                // ol doesn't add features with same id, update existing
                const existing = layerSource.getFeatureById(id);
                existing.setGeometry(new olGeom.Point(coord));
                existing.setStyle(olStyle);
            } else {
                layerSource.addFeature(feature);
            }
            const data = this._featureToMarkerData(feature);
            const addEvent = Oskari.eventBuilder('AfterAddMarkerEvent')(data, id);
            this.getSandbox().notifyAll(addEvent);
        },
        _removeMarkerFromMap: function (id) {
            const layerSource = this.getMarkersLayer().getSource();
            const feature = layerSource.getFeatureById(id);
            if (feature) {
                layerSource.removeFeature(feature);
            }
        },
        _featureToMarkerData: function (feature) {
            const id = feature.getId();
            const coord = feature.getGeometry().getCoordinates();
            const styleData = this._styleData[id];
            return {
                id,
                x: coord[0],
                y: coord[1],
                ...styleData
            };
        },
        /**
         * Change map marker visibility.
         * @method  @public changeMapMarkerVisibility
         * @param  {Boolean} visible  visibility is marker visible or not.
         * @param  {String} id  optional marker id for marker to change it's visibility, all markers visibility changed if not given.
         */
        changeMapMarkerVisibility: function (visible, id) {
            if (!id) {
                this.getMarkersLayer().setVisible(visible);
                return;
            }
            const layerSource = this.getMarkersLayer().getSource();
            if (visible) {
                const feature = this._hiddenMarkers[id];
                layerSource.addFeature(feature);
                delete this._hiddenMarkers[id];
            } else {
                const feature = layerSource.getFeatureById(id);
                this._hiddenMarkers[id] = feature;
                layerSource.removeFeature(feature);
            }
        },
        /**
         * @method enableGfi
         * Enables/disables the gfi functionality
         * @param {Boolean} blnEnable true to enable, false to disable
         */
        enableGfi: function (blnEnable) {
            var sandbox = this.getSandbox();
            var gfiReqBuilder = Oskari.requestBuilder(
                'MapModulePlugin.GetFeatureInfoActivationRequest'
            );
            var hiReqBuilder = Oskari.requestBuilder(
                'WfsLayerPlugin.ActivateHighlightRequest'
            );

            // enable or disable gfi requests
            if (gfiReqBuilder) {
                sandbox.request(this.getName(), gfiReqBuilder(blnEnable));
            }

            // enable or disable wfs highlight
            if (hiReqBuilder) {
                sandbox.request(this.getName(), hiReqBuilder(blnEnable));
            }
        },
        /**
         * @method setState
         * Set the bundle state
         * @param {Object} state bundle state as JSON
         */
        setState: function (state) {
            // Clear state
            this.getMarkersLayer().getSource().clear();
            this._hiddenMarkers = {};
            this._styleData = {};

            const { markers } = state || {};
            if (markers) {
                markers.forEach(marker => this.addMapMarker(marker, null, true));
            }
        },
        /**
         * Returns markers parameter for map link if any markers on map:
         * "&markers=shape|size|hexcolor|x_y|User input text___shape|size|hexcolor|x_y|input 2"
         * @return {String} link parameters
         */
        getStateParameters: function () {
            const { markers } = this.getState();
            return this.getMarkersString(markers);
        },
        getTransformedStateParameters: function (targetSrs) {
            const mapmodule = this.getMapModule();
            const currentSrs = mapmodule.getProjection();
            if (!targetSrs || targetSrs === currentSrs) {
                return this.getStateParameters();
            }
            const { markers } = this.getState();
            let transformedMarkers;
            try {
                transformedMarkers = markers.map(marker => {
                    const lonlat = mapmodule.transformCoordinates({ lon: marker.x, lat: marker.y }, currentSrs, targetSrs);
                    return {
                        ...marker,
                        x: lonlat.lon,
                        y: lonlat.lat
                    };
                });
            } catch (err) {
                transformedMarkers = [];
            };
            return this.getMarkersString(transformedMarkers);
        },
        getMarkersString: function (markers = []) {
            const { FIELD, MARKER, COORD } = SEPARATORS;
            const markerParams = markers.map(marker => {
                const { shape, size, color, x, y, msg } = marker;
                const encodedMsg = encodeURIComponent(msg);
                return shape + FIELD + size + FIELD + color + FIELD + x + COORD + y + FIELD + encodedMsg;
            });
            if (markerParams.length > 0) {
                return '&markers=' + markerParams.join(MARKER);
            }
            return '';
        },
        /**
         * @method getState
         * Returns the bundle state
         * @return {Object} bundle state as JSON
         */
        getState: function () {
            if (!this.getMarkersLayer().getVisible()) {
                return {};
            }
            const markers = this.getMarkersLayer().getSource().getFeatures()
                .map(feat => this._featureToMarkerData(feat))
                .filter(markerData => !markerData.transient);
            return { markers };
        }
    }, {
        extend: ['Oskari.mapping.mapmodule.plugin.AbstractMapModulePlugin'],
        /**
         * @static @property {string[]} protocol array of superclasses
         */
        protocol: [
            'Oskari.mapframework.module.Module',
            'Oskari.mapframework.ui.module.common.mapmodule.Plugin'
        ]
    }
);
